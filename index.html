<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シンプルお絵描きアプリ</title>
    <style>
        body {
            margin: 0;
            padding: 5px;
            font-family: Arial, sans-serif;
            background: #e8e8e8;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        
        .canvas-container {
            background: white;
            width: 95vw;
            box-sizing: border-box;
            position: relative;
        }
        
        #canvas {
            cursor: none;
            display: block;
            width: 100%;
            height: auto;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        .brush-preview {
            position: absolute;
            border: 1px solid #333;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            display: none;
        }
        
        .toolbar {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            width: 95vw;
            box-sizing: border-box;
            flex-wrap: wrap;
        }
        
        .color-input {
            width: 35px;
            height: 35px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            background: none;
        }
        
        .tool-btn {
            width: 35px;
            height: 35px;
            background: #f0f0f0;
            color: #666;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            touch-action: manipulation;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .tool-btn.active {
            background: #333;
            color: white;
        }
        
        .tool-btn:hover {
            background: #e0e0e0;
        }
        
        .tool-btn.active:hover {
            background: #444;
        }
        
        .brush-size {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: #666;
        }
        
        .brush-size input {
            width: 100px;
        }
        
        .btn {
            padding: 8px 16px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            touch-action: manipulation;
            flex-shrink: 0;
        }
        
        .btn:hover {
            background: #ff5252;
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        /* タブレット以上で少し大きく */
        @media (min-width: 768px) {
            .toolbar {
                padding: 15px 25px;
                gap: 25px;
            }
            
            .color-input {
                width: 40px;
                height: 40px;
            }
            
            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .brush-size input {
                width: 120px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="canvas" width="400" height="300"></canvas>
        <div class="brush-preview" id="brushPreview"></div>
    </div>
    
    <div class="toolbar">
        <input type="color" id="colorInput" class="color-input" value="#000000">
        
        <button class="tool-btn active" id="penTool" onclick="setTool('pen')">✎</button>
        <button class="tool-btn" id="eraserTool" onclick="setTool('eraser')">◼</button>
        <button class="tool-btn" id="eyedropperTool" onclick="setTool('eyedropper')">●</button>
        
        <div class="brush-size">
            <span id="sizeValue">5</span>px
            <input type="range" id="brushSize" min="1" max="50" value="5">
        </div>
        
        <button class="btn" onclick="clearCanvas()">⚇</button>
        <button class="btn" onclick="saveImage()">⧉</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorInput = document.getElementById('colorInput');
        const brushSizeSlider = document.getElementById('brushSize');
        const sizeValueDisplay = document.getElementById('sizeValue');
        const brushPreview = document.getElementById('brushPreview');
        
        let isDrawing = false;
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let currentTool = 'pen';
        let lastX = 0;
        let lastY = 0;
        
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // レスポンシブキャンバスサイズ調整
        function adjustCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const toolbarHeight = document.querySelector('.toolbar').offsetHeight;
            const availableHeight = window.innerHeight - toolbarHeight - 20; // 少しの余白
            
            canvas.width = containerWidth;
            canvas.height = availableHeight;
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }
        
        // ブラシプレビューの更新
        function updateBrushPreview() {
            const size = currentBrushSize;
            brushPreview.style.width = size + 'px';
            brushPreview.style.height = size + 'px';
            
            if (currentTool === 'eraser') {
                brushPreview.style.borderColor = '#ff6b6b';
                brushPreview.style.backgroundColor = 'rgba(255, 107, 107, 0.2)';
            } else if (currentTool === 'eyedropper') {
                brushPreview.style.borderColor = '#333';
                brushPreview.style.backgroundColor = 'transparent';
            } else {
                brushPreview.style.borderColor = currentColor;
                brushPreview.style.backgroundColor = 'transparent';
            }
        }
        
        // ツール切り替え
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
            updateBrushPreview();
        }
        
        // キャンバスクリア
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // 画像保存
        function saveImage() {
            const link = document.createElement('a');
            link.download = 'drawing_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // 描画開始
        function startDrawing(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'eyedropper') {
                const imageData = ctx.getImageData(x, y, 1, 1);
                const pixel = imageData.data;
                if (pixel[3] > 0) {
                    const hex = '#' + 
                        ('0' + pixel[0].toString(16)).slice(-2) +
                        ('0' + pixel[1].toString(16)).slice(-2) +
                        ('0' + pixel[2].toString(16)).slice(-2);
                    currentColor = hex;
                    colorInput.value = hex;
                    updateBrushPreview();
                }
                return;
            }
            
            isDrawing = true;
            lastX = x;
            lastY = y;
            
            ctx.beginPath();
            ctx.moveTo(x, y);
        }
        
        // 描画停止
        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath();
        }
        
        // キャンバスクリア（確認付き）
        function confirmClear() {
            if (confirm('本当にすべて消去しますか？')) {
                clearCanvas();
            }
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // 画像保存（確認付き）
        function confirmSave() {
            if (confirm('画像を保存しますか？')) {
                saveImage();
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = 'drawing_' + new Date().toISOString().slice(0,19).replace(/:/g, '-') + '.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // タッチイベント処理
        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        }
        
        // イベントリスナー設定
        adjustCanvas();
        window.addEventListener('resize', adjustCanvas);
        
        // カラーピッカー
        colorInput.addEventListener('input', (e) => {
            currentColor = e.target.value;
            updateBrushPreview();
        });
        
        // ブラシサイズ
        brushSizeSlider.addEventListener('input', (e) => {
            currentBrushSize = e.target.value;
            sizeValueDisplay.textContent = currentBrushSize;
            updateBrushPreview();
        });
        
        // マウスイベント
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            brushPreview.style.left = (x - currentBrushSize / 2) + 'px';
            brushPreview.style.top = (y - currentBrushSize / 2) + 'px';
            brushPreview.style.display = 'block';
            
            if (isDrawing && currentTool !== 'eyedropper') {
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = currentColor;
                }
                
                ctx.lineWidth = currentBrushSize;
                
                // スムーズな線のためのベジェ曲線補間
                const midX = (lastX + x) / 2;
                const midY = (lastY + y) / 2;
                
                ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                ctx.stroke();
                
                lastX = x;
                lastY = y;
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            brushPreview.style.display = 'none';
        });
        
        canvas.addEventListener('mouseenter', () => {
            brushPreview.style.display = 'block';
            updateBrushPreview();
        });
        
        // タッチイベント
        canvas.addEventListener('touchstart', handleTouch);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', stopDrawing);
        
        // 初期設定
        updateBrushPreview();
    </script>
</body>
</html>
